package main

import (
	"fmt"
	"time"
)

//AS OPERAÇÕES DO CANAL BLOQUEIAM A EXECUÇÃO APÓS O CANAL RECEBER O CANAL ELE SAI DA EXECUÇÃO
func escrever(text string, channel chan string) {
	for i := 0; i < 5; i++ {
		// AO UTILIZAR A SINTAXE DE CANAL<-VALOR ESTAMOS COLOCANDO VALORES DENTRO DO CANAL PARA SEREM RECEBIDOS DO OUTRO LADO 
		channel <- text
		time.Sleep(time.Second)
	}
	//AQUI CONSEGUIMOS FAZER O USO DE UMA FUNÇÃO CLOSE() ELA É RESPONSÁVEL POR APÓS ENVIARMOS TODOS OS DADOS 
	//ELE FECHE O CANAL EVITANDO PROBLEMAS DE ESPERA
	close(channel)
}

func main()  {
	//CANAIS SÃO UMA MANEIRA EFICIENTE E CORRETA PARA SE TRABALHAR COM GOROUTINES
	//ELES PODEM TANTO RECEBER COMO ENVIAR DADOS ENTRE ELES
	channel := make(chan string)
	go escrever("Hello Channel", channel)
	//AO UTILIZAR A SINTAXE <-CANAL ESTAMOS ESCUTANDO O RETORNO DOS DADOS DESTE CANAL
	// É EXETAMENTE NESTE PONTO QUE ESPERAMOS O VALOR QUE VAI SER RECEBIDO DESSA FORMA ELE "ESPERA" UM RETORNO

	// for {	
	// 	mensage, open := <-channel
	// 	//AQUI VERIFICAMOS SE O CANAL AINDA ESTÁ ABERTO, CASO O CONTRÁRIO PODEMOS SAIR DO LOOP EVITANDO O DEADLOCK
	// 	if !open {
	// 		break
	// 	}
	// 	fmt.Println(mensage)
	// }

	//PARA CADA MENSAGEM QUE FOR RECEBIDA NO CANAL VOU PRINTAR NA TELA ENQUANTO O CANAL ESTIVER ABERTO
	for mensagem := range channel {
		fmt.Println(mensagem)
	}
	fmt.Println("Acabou!!")
	//AQUI PODEMOS VERIFICAR UM ERRO CHAMADO DEADLOCK, ACONTECE QUANDO NOSSO CANAL FICA ESPERANDO UM RETORNO ETERNAMENTE.
	//ESSE DEADLOCK NÃO É PEGO EM COMPILAÇÃO SOMENTE EM RUNTIME. 
}